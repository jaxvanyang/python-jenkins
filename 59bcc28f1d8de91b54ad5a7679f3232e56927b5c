{
  "comments": [
    {
      "key": {
        "uuid": "9f91af0f_b4e7c8e4",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 256,
      "author": {
        "id": 679
      },
      "writtenOn": "2018-01-05T17:11:48Z",
      "side": 1,
      "message": "This really doesn\u0027t look right to me.  We\u0027re basing the decision on whether to go with Kerberos authentication solely on the presence of the requests_kerberos module; so, if someone has requests_kerberos installed for some other reason, they\u0027re forced to use Kerberos authentication even if their target Jenkins isn\u0027t actually set up to support it.  I\u0027d say we really need to have another argument to the constructor to control whether we use Kerberos or basic authentication.",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f91af0f_ba356f48",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 256,
      "author": {
        "id": 1054
      },
      "writtenOn": "2018-01-05T18:30:53Z",
      "side": 1,
      "message": "Is that any different to the decision being based on whether they have \u0027kerberos\u0027 installed with the existing codebase?\n\nI\u0027m happy to add another argument to the constructor, but is it ok to break with existing behaviour then by not automagically using kerberos if a particular library is present?\n\nActually looking closer at the existing code, what might need to be done is test if the kerberos authentication works, and then fall back to the BasicAuth if it doesn\u0027t, setting on the session then for all subsequent requests. But still this should probably only be done on the first requests.",
      "parentUuid": "9f91af0f_b4e7c8e4",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f91af0f_8e65d0e3",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 256,
      "author": {
        "id": 679
      },
      "writtenOn": "2018-01-05T18:45:54Z",
      "side": 1,
      "message": "Yeah, sounds like we\u0027ve shot ourselves in the foot if the existing behavior is to go kerberos if a particular library is present.  Doing the fall-back to BasicAuth would be acceptable to me, though; that may be something we could do with a custom authentication type, btw.",
      "parentUuid": "9f91af0f_ba356f48",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f91af0f_140a3489",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 264,
      "author": {
        "id": 679
      },
      "writtenOn": "2018-01-05T17:11:48Z",
      "side": 1,
      "message": "If we\u0027re allocating a session, I\u0027d argue that we should set the authentication on the session directly, rather than on each request, which is what we appear to be doing right now.",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f91af0f_3ae5dfa8",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 264,
      "author": {
        "id": 1054
      },
      "writtenOn": "2018-01-05T18:30:53Z",
      "side": 1,
      "message": "good idea",
      "parentUuid": "9f91af0f_140a3489",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5f93b717_9c011808",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 264,
      "author": {
        "id": 1054
      },
      "writtenOn": "2018-02-02T12:36:35Z",
      "side": 1,
      "message": "I\u0027ve tested this extensively now, and it doesn\u0027t appear to work the way you\u0027d expect. Setting self._session.auth to the desired value does not appear to get applied to a \u0027PreppedRequest\u0027 that is then sent via Session.send(...).\n\nYou can set defaults in the Session, but it seems it\u0027s limited to simple properties. I suspect the problem is that auth is a called class that will apply headers to the request rather than a attribute. If using simple values (user, pass) it apparently works, but I suspect it\u0027s because it then passes it to a default Basic auth class to apply the headers. Using one of the auth classes directly as we need to do, unfortunately doesn\u0027t work.",
      "parentUuid": "9f91af0f_140a3489",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5f93b717_31e586dc",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 264,
      "author": {
        "id": 679
      },
      "writtenOn": "2018-02-02T18:26:16Z",
      "side": 1,
      "message": "I actually wondered about that, because of how we\u0027re passing in Request rather than allocating one in the context of the session.  That might come back to the argument over whether to pass Request to jenkins_open() vs. having jenkins_open() make the appropriate request by calling, e.g., _session.get()/_session.post().\n\nOn another topic, I looked at the requests documentation on sessions[1], and it points out this same phenomenon, and says this: \"However, the above code will lose some of the advantages of having a Requests Session object. In particular, Session-level state such as cookies will not get applied to your request. To get a PreparedRequest with that state applied, replace the call to Request.prepare() with a call to Session.prepare_request()[.]\"\n\nBased on that, we might want to look at using something along the lines of:\n\n    self._session.prepare_request(req)\n\nbefore the rest of the logic in jenkins_open()\n\n[1] http://docs.python-requests.org/en/master/user/advanced/#session-objects",
      "parentUuid": "5f93b717_9c011808",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f91af0f_54ef5caf",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 267,
      "author": {
        "id": 679
      },
      "writtenOn": "2018-01-05T17:11:48Z",
      "side": 1,
      "message": "There\u0027s no need to coerce the output of keys() to a list; regardless of Python version, the result will be an iterable, which we then iterate over.",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f91af0f_1af49b5a",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 267,
      "author": {
        "id": 1054
      },
      "writtenOn": "2018-01-05T18:30:53Z",
      "side": 1,
      "message": "good point, not sure why I did that, wonder if there is an issue if you update keys in a dict while iterating over it, I\u0027ve a feeling that that I was assuming that it could sometimes result in entries being skipped.",
      "parentUuid": "9f91af0f_54ef5caf",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f91af0f_0e9f80b4",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 267,
      "author": {
        "id": 679
      },
      "writtenOn": "2018-01-05T18:45:54Z",
      "side": 1,
      "message": "Probably, but I don\u0027t see why we would mutate params if we\u0027re then going to return the mutated version.  I think we need to look closer at how this routine is used (I didn\u0027t during my previous review) and think about other ways of addressing the need…",
      "parentUuid": "9f91af0f_1af49b5a",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f91af0f_ca02c93d",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 267,
      "author": {
        "id": 1054
      },
      "writtenOn": "2018-01-08T11:16:15Z",
      "side": 1,
      "message": "I don\u0027t think it\u0027s mutating them, but with python3 because params.keys(), params.values() \u0026 params.items() are all view objects, even replacing a key\u0027s value can result in a slightly different layout altering any existing views in a way where you could end up skipping an element you were previously going to iterate over.\n\nI\u0027ll test, but I suspect the reason I included the change here was because I was hitting this issue.\n\nSee https://stackoverflow.com/a/6777832 and https://cito.github.io/blog/never-iterate-a-changing-dict/\n\nOnce confirmed, I\u0027ll move it out to a separate patch in any case.",
      "parentUuid": "9f91af0f_0e9f80b4",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f91af0f_9ef87a49",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 267,
      "author": {
        "id": 679
      },
      "writtenOn": "2018-01-08T16:57:52Z",
      "side": 1,
      "message": "Yep, it makes sense to me that modifying the dict could make keys unstable.  I honestly wouldn\u0027t expect that to be a problem during iteration—the size of the dict isn\u0027t being altered—but I haven\u0027t looked at the details of how Python does dicts, so…",
      "parentUuid": "9f91af0f_ca02c93d",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f96bb07_5cd01dca",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 267,
      "author": {
        "id": 1054
      },
      "writtenOn": "2018-01-22T19:02:03Z",
      "side": 1,
      "message": "I\u0027ve reverted this piece temporarily, I think it\u0027s only encountered when running python 3.6, which means we\u0027ll need to fix at some point, but it\u0027s not part of this change.",
      "parentUuid": "9f91af0f_9ef87a49",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f91af0f_746dc030",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 270,
      "author": {
        "id": 679
      },
      "writtenOn": "2018-01-05T17:11:48Z",
      "side": 1,
      "message": "I\u0027m not sure I understand why we went from iterating over .items() to iterating over .keys() and getting the value from params.  If we\u0027re going to do that, then maybe we should change this whole thing to:\n\n    _valid_keys \u003d [\"name\", \"msg\", …]\n    …\n    def _get_encoded_params(self, params):\n        return {k: quote(params[k]) for k in self._valid_keys\n                if k in params}",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f91af0f_1ac25bea",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 270,
      "author": {
        "id": 1054
      },
      "writtenOn": "2018-01-05T18:30:53Z",
      "side": 1,
      "message": "I might drop this piece from the change anyway, as it shouldn\u0027t impact and we can update as needed in the future.",
      "parentUuid": "9f91af0f_746dc030",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f91af0f_34817890",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 287,
      "author": {
        "id": 679
      },
      "writtenOn": "2018-01-05T17:11:48Z",
      "side": 1,
      "message": "We\u0027re using this idiom over and over again, where we call self.jenkins_open() on a requests.Request() that we create inline, or possibly before the jenkins_open() in some places.  I have to wonder if we could instead have jenkins_open() create the request for us?  Maybe that needs to be a future patch, since this is just converting from Request to requests.Request, but something to think about.",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f91af0f_9a518b65",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 287,
      "author": {
        "id": 1054
      },
      "writtenOn": "2018-01-05T18:30:53Z",
      "side": 1,
      "message": "Possibly, though it would certainly complicate the jenkins_open call, and also change the the API, though maybe this change is sufficient that we would need a major version bump before releasing, in which case should definitely make the change before continuing.",
      "parentUuid": "9f91af0f_34817890",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f91af0f_aecc54bc",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 287,
      "author": {
        "id": 679
      },
      "writtenOn": "2018-01-05T18:45:54Z",
      "side": 1,
      "message": "*nod* I\u0027d say we\u0027re making a pretty major change going to requests anyway, so we can probably take the opportunity to additionally clean up some API elements.",
      "parentUuid": "9f91af0f_9a518b65",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f91af0f_0a38b13a",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 287,
      "author": {
        "id": 1054
      },
      "writtenOn": "2018-01-08T11:16:15Z",
      "side": 1,
      "message": "Thinking about it over the weekend, the one advantage is that you can construct a requests object to have whatever arguments you need and pass it to jenkins_open(), without the function needing to know anything more than it is a requests object and whether to add the crumb or not.\n\nTo achieve the same flexibility we would eventually end up with a definition like the following:\n\n def jenkins_open(self, add_crumb\u003dTrue, *args, **kwargs):\n \n     req \u003d requests.Request(*args, **kwargs)\n\n     ....\n\n\nIs that better or worse than the current?",
      "parentUuid": "9f91af0f_aecc54bc",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f91af0f_f9a200fc",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 287,
      "author": {
        "id": 679
      },
      "writtenOn": "2018-01-08T16:57:52Z",
      "side": 1,
      "message": "You have a good point about that.  The way I\u0027ve usually approached creating Python clients has been to create _get(), _post(), etc. methods that take a path and other data, then have those methods call the appropriate methods on the session created by the constructor…but that\u0027s hardly the only way to accomplish this task, and the jenkins_open() method is just as valid, and has the advantage of letting users set up their own calls.  Given how extensive the Jenkins API is, and how easily Jenkins plugins can add to it, sticking with the existing methodology makes sense.  I do have to point out that we are changing the interface, though, as now users have to allocate a requests.Request instead of a urllib Request.  That may require some additional communication and a version bump, if we truly consider jenkins_open() to be an exposed interface…",
      "parentUuid": "9f91af0f_0a38b13a",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f91af0f_74db80ec",
        "filename": "jenkins/__init__.py",
        "patchSetId": 16
      },
      "lineNbr": 448,
      "author": {
        "id": 679
      },
      "writtenOn": "2018-01-05T17:11:48Z",
      "side": 1,
      "message": "I wonder if we could drop the extraneous \u0027+\u0027 operator here…",
      "revId": "59bcc28f1d8de91b54ad5a7679f3232e56927b5c",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    }
  ]
}