{
  "comments": [
    {
      "key": {
        "uuid": "3a50d1a3_27b035dd",
        "filename": "jenkins/__init__.py",
        "patchSetId": 4
      },
      "lineNbr": 199,
      "author": {
        "id": 1054
      },
      "writtenOn": "2015-07-20T14:27:52Z",
      "side": 1,
      "message": "I\u0027m a little concerned that err_handle is somewhat misleading. What about a custom err_handler for other errors that occur, such as providing a callback to provide handling for other errors.\n\nI would suggest something that identifies this as response decoding at least.\n\nRather than trying to hack various options in to allow changing how we handle different error scenarios, perhaps a setting to control whether we return the raw response object instead of the response it self would be a solution here?",
      "revId": "b8c3100c15d26eaf4df4608911b9156a3f98cec7",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a50d1a3_9d4958d3",
        "filename": "jenkins/__init__.py",
        "patchSetId": 4
      },
      "lineNbr": 199,
      "author": {
        "id": 16889
      },
      "writtenOn": "2015-07-20T14:49:38Z",
      "side": 1,
      "message": "first understand the issue then you can offer a different name for this variable",
      "parentUuid": "3a50d1a3_27b035dd",
      "revId": "b8c3100c15d26eaf4df4608911b9156a3f98cec7",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a50d1a3_871d8975",
        "filename": "jenkins/__init__.py",
        "patchSetId": 4
      },
      "lineNbr": 208,
      "author": {
        "id": 1054
      },
      "writtenOn": "2015-07-20T14:27:52Z",
      "side": 1,
      "message": "trailing slash is not needed, just indent the following line by 4 spaces from the start of the preceding line and sphinx will handle the continuation just fine.",
      "revId": "b8c3100c15d26eaf4df4608911b9156a3f98cec7",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a50d1a3_1dfea86b",
        "filename": "jenkins/__init__.py",
        "patchSetId": 4
      },
      "lineNbr": 208,
      "author": {
        "id": 16889
      },
      "writtenOn": "2015-07-20T14:49:38Z",
      "side": 1,
      "message": "ok first finish other remarks",
      "parentUuid": "3a50d1a3_871d8975",
      "revId": "b8c3100c15d26eaf4df4608911b9156a3f98cec7",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a50d1a3_c74631bf",
        "filename": "jenkins/__init__.py",
        "patchSetId": 4
      },
      "lineNbr": 322,
      "author": {
        "id": 1054
      },
      "writtenOn": "2015-07-20T14:27:52Z",
      "side": 1,
      "message": "What is the problem that you\u0027re running into with the strict decoding? Can you simulate this with a basic test.",
      "revId": "b8c3100c15d26eaf4df4608911b9156a3f98cec7",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a50d1a3_7de24cd7",
        "filename": "jenkins/__init__.py",
        "patchSetId": 4
      },
      "lineNbr": 322,
      "author": {
        "id": 16889
      },
      "writtenOn": "2015-07-20T14:49:38Z",
      "side": 1,
      "message": "\u003e\u003e\u003e encodings.codecs.utf_8_decode(\u0027\\x00\\x00\\xfe\\xff\u0027)\nTraceback (most recent call last):\n  File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e\nUnicodeDecodeError: \u0027utf8\u0027 codec can\u0027t decode byte 0xfe in position 2: invalid start byte\n\u003e\u003e\u003e encodings.codecs.utf_8_decode(\u0027\\x00\\x00\\xfe\\xff\u0027,\u0027ignore\u0027)\n(u\u0027\\x00\\x00\u0027, 4)",
      "parentUuid": "3a50d1a3_c74631bf",
      "revId": "b8c3100c15d26eaf4df4608911b9156a3f98cec7",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a50d1a3_a75d16eb",
        "filename": "jenkins/__init__.py",
        "patchSetId": 4
      },
      "lineNbr": 322,
      "author": {
        "id": 1054
      },
      "writtenOn": "2015-07-20T18:29:06Z",
      "side": 1,
      "message": "Ok, to be more specific:\n\nWhat response are you getting from a Jenkins server that triggers this?\n\nCan always provide garbage to trigger an error somewhere, but that doesn\u0027t actually identify in what scenarios would a response back from Jenkins not be utf-8 encoded.",
      "parentUuid": "3a50d1a3_7de24cd7",
      "revId": "b8c3100c15d26eaf4df4608911b9156a3f98cec7",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a50d1a3_a75f5671",
        "filename": "jenkins/__init__.py",
        "patchSetId": 4
      },
      "lineNbr": 322,
      "author": {
        "id": 16889
      },
      "writtenOn": "2015-07-20T18:38:20Z",
      "side": 1,
      "message": "i\u0027m running a very long script that compiles lots of stuff, this exception happens when i\u0027m trying to get the output.\nyou can blame the script but still this module is not flexible enough",
      "parentUuid": "3a50d1a3_a75d16eb",
      "revId": "b8c3100c15d26eaf4df4608911b9156a3f98cec7",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a50d1a3_837d60b3",
        "filename": "jenkins/__init__.py",
        "patchSetId": 4
      },
      "lineNbr": 322,
      "author": {
        "id": 1054
      },
      "writtenOn": "2015-07-21T00:53:53Z",
      "side": 1,
      "message": "Is there anyway to debug the raw response due to that script?\n\nI suspect the underlying problem is that we are decoding a response that is not in utf-8 and has a different charset specified in the headers. So if instead of just assuming utf-8, we decoded the response based on what we\u0027re told to use to decode (provided we check that the return type is actually text), it would work as expected.\n\nOther than that, I would be looking to change the code to register a custom response handler that is called each time, where the default is to decode the response using the charset from the headers.\n\nBut allowing to ignore the errors means that we are returning a potentially corrupted response instead, with no way for the caller to get the original response to do anything with it. That potentially renders the response worthless and at the same time adds another option to the API that must be supported in the future.\n\n\nIf we can\u0027t decode the response correctly, then we need to find a way to allow the caller to handle the response instead rather than trashing it and returning garbage.",
      "parentUuid": "3a50d1a3_a75f5671",
      "revId": "b8c3100c15d26eaf4df4608911b9156a3f98cec7",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a50d1a3_8cca656d",
        "filename": "jenkins/__init__.py",
        "patchSetId": 4
      },
      "lineNbr": 322,
      "author": {
        "id": 16889
      },
      "writtenOn": "2015-07-21T07:53:42Z",
      "side": 1,
      "message": "i have no idea what is the char-set of the response and how to check it, if you will explain how i can check this.\nbut i do know that the assumption that jenkins returns utf8 is wrong and causes errors.",
      "parentUuid": "3a50d1a3_837d60b3",
      "revId": "b8c3100c15d26eaf4df4608911b9156a3f98cec7",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a50d1a3_32fd9b3a",
        "filename": "jenkins/__init__.py",
        "patchSetId": 4
      },
      "lineNbr": 322,
      "author": {
        "id": 1054
      },
      "writtenOn": "2015-07-21T14:05:07Z",
      "side": 1,
      "message": "So a few lines above where we call:\n\n    response \u003d urlopen(req, timeout\u003dself.timeout).read()\n\nWe should probably really drop the .read() call and hold onto the response object returned by urlopen by using:\n\n    response \u003d urlopen(req, timeout\u003dself.timeout)\n    contents \u003d response.read()\n    if contents is None:\n        ....\n\nThe response object then in this case is like a file object, but also contains the methods info(), getcode() and geturl() to retrieve addition information.\n\nSee https://docs.python.org/2/library/urllib.html#high-level-interface for details. Basically the info() method returns an instance of mimetools.Message that can be queried using gettype() to determine the content type which will return \u0027text/plain\u0027 if none is defined. We should probably check this to ensure it starts with \u0027text/\u0027 before attempting to read the contents, and also before attempting to decode anything. i.e.\n\n    if response.info().getmaintype() \u003d\u003d \u0027text\u0027:\n        # only read and decode text data\n\nAdditionally the mimetools.Message has a method getplist() (https://docs.python.org/2/library/mimetools.html#mimetools.Message.getplist) which will return everything in the header \u0027Content-Type: text/plain; \u003cextra data\u003e\u0027 listed in \"\u003cextra data\u003e\" which is exactly where the charset would be defined.\n\nI would expect we should be getting the following header from Jenkins:\n\n    Content-Type:text/xml; charset\u003dutf-8\n\nReading the documentation on https://docs.python.org/2/library/mimetools.html#module-mimetools suggests that the following should be used to extract the expected charset:\n\n        charset \u003d response.info().getparam(\u0027charset\u0027)\n        return contents.decode(charset)\n\n\nPutting this altogether:\n\n    response \u003d urlopen(req, timeout\u003dself.timeout)\n    mimedata \u003d response.info()\n    if mimedata.getmaintype() \u003d\u003d \u0027text\u0027:\n        # only read and decode text data\n        contents \u003d response.read()\n        # provide a default of utf-8 if it\u0027s missing\n        charset \u003d mimedata.getparam(\u0027charset\u0027) or \u0027utf-8\u0027\n        return contents.decode(charset)\n    else:\n        # return the raw contents, though this may not be a good idea\n        # with a long stream of data\n        return response.read()\n\n\nHowever as you\u0027ve stated this is still a little limited, so I would suggest placing from \u0027mimedata \u003d response.info()\u0027 downwards into a _response_handler method on the object, and have the init function take a custom response_handler callback to use instead of the default.\n\nThis would allow for situations where we cannot predict how people will use the API calls to customize how the response is handled to their application usage.\n\nUnfortunately digging through the documentation suggests that the above won\u0027t work on python 3, so it looks as though we probably also need to switch to using the requests library to be able to handle various responses.\n\nIt would be still be a useful information point if you can patch locally with the above suggestion to establish whether the idea works in your case. At the very least that may allow you to add some print statements to dump out information about what headers are defined and the charset detected.\n\nI will look at converting the library to use \"requests\" instead, which will probably clean up a few things and provide a generic python 2/3 version of a response_handler and then this change could be co-opted to add support for a custom response_handler to be registered through the constructor.",
      "parentUuid": "3a50d1a3_8cca656d",
      "revId": "b8c3100c15d26eaf4df4608911b9156a3f98cec7",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    }
  ]
}